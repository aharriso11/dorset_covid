'areaCode=E92000001'
)
# query filter for SW
filter_rsw <-c(
'areaType=nhsRegion',
'areaCode=E40000006'
)
# query filter for RBD
filter_rbd <-c(
'areaType=nhsTrust',
'areaCode=RBD'
)
# query filter for R0D
filter_r0d <-c(
'areaType=nhsTrust',
'areaCode=R0D'
)
# data structure for the API call
df_structure <- c(date = "date",
areaName = "areaName",
areaCode = "areaCode",
hospitalCases = "hospitalCases",
newAdmissions = 'newAdmissions'
)
# call data
df_eng <- get_data(
filters = filter_eng,
structure = df_structure
)
df_rsw <- get_data(
filters = filter_rsw,
structure = df_structure
)
df_rbd <- get_data(
filters = filter_rbd,
structure = df_structure
)
df_r0d <- get_data(
filters = filter_r0d,
structure = df_structure
)
# waves
df_waves <- tibble(
start = c(as.Date(c("2020-03-01")), as.Date(c("2020-09-01")), as.Date(c("2021-05-01"))),
end = c(as.Date(c("2020-08-31")), as.Date(c("2021-04-30")), as.Date(today())),
Wave = c("Wave 1", "Wave 2", "Wave 3"),
colours =c("red", "blue", "forestgreen")
)
# waves
df_waves <- tibble(
start = c(as.Date(c("2020-03-01")), as.Date(c("2020-09-01")), as.Date(c("2021-05-01"))),
end = c(as.Date(c("2020-08-31")), as.Date(c("2021-04-30")), as.Date(today())),
Wave = c("Wave 1", "Wave 2", "Wave 3")
)
# merge datasets into one
# 1 - place datasets into a single list
df_list <- list(df_eng, df_rsw, df_rbd, df_r0d)
# 2 - merge the datasets in the list into vaccs_combined
df_combined <- merge_recurse(df_list)
# define the date format
df_combined$date = as.Date(df_combined$date, "%Y-%m-%d")
# averages
df_combined <- df_combined %>%
group_by(areaCode) %>%
mutate(hospitalCasesA = rollmean(hospitalCases, k = 7, fill = NA)) %>%
mutate(newAdmissionsA = rollmean(newAdmissions, k = 7, fill = NA))
#convert to tibble
as_tibble(df_combined)
df_combined <- fuzzy_left_join(
df_combined, df_waves,
by = c(
"date" = "start",
"date" = "end"
),
match_fun = list(`>=`, `<=`)
) %>%
select(areaCode, areaType, areaName, date, hospitalCasesA, newAdmissionsA, Wave)
df_combined <- df_combined %>%
filter(!is.na(newAdmissionsA) & !is.na(hospitalCasesA))
df_latest <- df_combined %>%
group_by(areaCode) %>%
slice(which.max(date))
df_plot <- ggplot() +
geom_point(data = df_combined, aes(x = newAdmissionsA, y = hospitalCasesA, colour = Wave), shape = 1, size = 2) +
geom_point(data = df_latest, aes(x = newAdmissionsA, y = hospitalCasesA), colour = "black", shape = 16, size = 2) +
facet_wrap( ~ areaName, scales = "free") +
scale_colour_manual(name = "Wave", values = c("Wave 1" = "red", "Wave 2" = "blue", "Wave 3" = "limegreen")) +
xlab("New admissions to hospital with covid-19") +
ylab("Cases of people in hospital with covid-19") +
# set title and subtitle
ggtitle("Comparing covid hospital admissions with cases in hospital") +
labs(caption = paste("Data from the UK Health Security Agency. Plotted", Sys.time(), sep = " ", "\nData plot by Andrew Harrison / https://aharriso11.github.io/dorset_covid, and inspired by @bristoliver"),
subtitle = "The daily number of new admissions to hospital of patients with covid-19, compared with the daily number of confirmed covid-19 patients in hospital.<br>
If the black dot goes up, the number of people in hospital with covid-19 is rising. If the black dot moves to the right, the number of people being admitted to hospital with covid-19 is rising.<br>
<b><span style='color:red;'>Wave 1</span></b> ran from 1st March 2020 to 31st August 2020. <b><span style='color:blue;'>Wave 2</span></b> ran from 1st September 2020 to 30th April 2021. <b><span style='color:limegreen;'>Wave 3</span></b> began on 1st May 2021 and is the current wave."
) +
# set theme and customisations
theme_base() +
theme(
axis.text.x = element_text(size = 8),
axis.text.y = element_text(size = 8),
plot.title = element_text(size = 20, family = "Helvetica", face = "bold"),
plot.subtitle = element_markdown(hjust = 0, vjust = 0, size = 11),
plot.caption = element_text(size = 8),
legend.title = element_text(size = 12, face = "bold"),
legend.text = element_text(size = 10),
legend.background = element_blank(),
legend.box.background = element_rect(colour = "black"),
axis.title = element_text(size = 12),
axis.text = element_text(size = 8),
strip.text.y = element_text(size = 9.5),
strip.text.x = element_text(size = 9.5, face = "bold"))
df_plot
# save to daily file
ggsave("output/hosp_phase.png", width = 16.6, height = 16.6, units = "in")
# save to daily file
ggsave("output/hosp_phase.png", width = 16.6, height = 8.65, units = "in")
# set working directory
setwd("~/Documents/GitHub/dorset_covid")
# set technical briefing spreadsheet path
sheet_path <- "https://assets.publishing.service.gov.uk/government/uploads/system/uploads/attachment_data/file/1046608/variants-of-concern-technical-briefing-34-data-england-14-January-2022-1.ods"
# set plot title
plot_subtitle <- "Variant prevalence for all England available sequenced cases from 31 January 2021 as of 10 January 2022"
# set plot caption
plot_caption <- "Data from UK Health Security Agency technical briefing 34 (gateway number GOV-10924)."
# set file name
file_name <- "devel/techreport34.ods"
# Install the pacman package to call all the other packages
if (!require("pacman")) install.packages("pacman")
# Use pacman to install (if req) and load required packages
pacman::p_load(
httr,
readxl,
readODS,
tidyr,
ggplot2,
dplyr,
zoo,
data.table,
scales,
glue,
ggtext,
ggthemes,
pals
)
GET(sheet_path, write_disk(file_name, overwrite = TRUE))
# Import raw data from Excel
covid_variant_data <- read_ods(file_name, sheet = "Fig2", skip = 2)
View(covid_variant_data)
# set the date format
covid_variant_data$week = as.Date(covid_variant_data$week, "%m/%d/%Y")
# convert wide data to long
covid_variant_data <- gather(covid_variant_data, variant, case_prevelance, -c(week))
View(covid_variant_data)
# Import raw data from Excel
covid_variant_data <- read_ods(file_name, sheet = "Fig2", skip = 2)
# set the date format
covid_variant_data$week = as.Date(covid_variant_data$week, "%m/%d/%Y")
# convert wide data to long
covid_variant_data <- gather(covid_variant_data, variant, case_prevelance, "Omicron":last_col())
View(covid_variant_data)
# create plot and geom
covid_variant_plot <- ggplot() +
# plot data in a stacked format
geom_area(data = covid_variant_data, aes(x = week, y = case_prevelance, group = variant, fill = variant), position = "stack") +
# scale settings
scale_fill_manual(name = "Variant", values = as.vector(tableau20(19))) +
scale_x_date(date_labels = "%b %y", date_breaks = "1 month") +
# axis settings
xlab("Month") +
ylab("Case prevelance percentage") +
# titles
ggtitle("Covid variant prevalence in England") +
labs(caption = paste0(plot_caption," Plotted", Sys.time(), sep = " "), subtitle = paste0(plot_subtitle)) +
# set theme
theme_base() +
theme(
plot.title = element_text(size = 20, family = "Helvetica", face = "bold"),
plot.subtitle = element_markdown(hjust = 0, vjust = 0, size = 11),
plot.caption = element_text(size = 10))
covid_variant_plot
# Import raw data from Excel
covid_variant_data <- read_ods(file_name, sheet = "Fig2", skip = 2)
View(covid_variant_data)
# set the date format
covid_variant_data$week = as.Date(covid_variant_data$week, "%m/%d/%Y")
# convert wide data to long
covid_variant_data <- gather(covid_variant_data, variant, case_prevelance, "Omicron":last_col())
# set working directory
setwd("~/Documents/GitHub/dorset_covid")
# set technical briefing spreadsheet path
sheet_path <- "https://assets.publishing.service.gov.uk/government/uploads/system/uploads/attachment_data/file/1043695/variants-of-concern-technical-briefing-33-data-england-23-december-2021.ods"
# set plot title
plot_subtitle <- "Variant prevalence for all England available sequenced cases from 31 January 2021 as of 21 December 2021"
# set plot caption
plot_caption <- "Data from UK Health Security Agency technical briefing 33 (gateway number GOV-10869)."
# set file name
file_name <- "devel/techreport33.ods"
# Install the pacman package to call all the other packages
if (!require("pacman")) install.packages("pacman")
# Use pacman to install (if req) and load required packages
pacman::p_load(
httr,
readxl,
readODS,
tidyr,
ggplot2,
dplyr,
zoo,
data.table,
scales,
glue,
ggtext,
ggthemes,
pals
)
GET(sheet_path, write_disk(file_name, overwrite = TRUE))
# Import raw data from Excel
covid_variant_data <- read_ods(file_name, sheet = "Fig2", skip = 2)
View(covid_variant_data)
# set the date format
covid_variant_data$week = as.Date(covid_variant_data$week, "%m/%d/%Y")
# convert wide data to long
covid_variant_data <- gather(covid_variant_data, variant, case_prevelance, "Omicron":last_col())
# set working directory
setwd("~/Documents/GitHub/dorset_covid")
# set technical briefing spreadsheet path
sheet_path <- "https://assets.publishing.service.gov.uk/government/uploads/system/uploads/attachment_data/file/1046608/variants-of-concern-technical-briefing-34-data-england-14-January-2022-1.ods"
# set plot title
plot_subtitle <- "Variant prevalence for all England available sequenced cases from 31 January 2021 as of 10 January 2022"
# set plot caption
plot_caption <- "Data from UK Health Security Agency technical briefing 34 (gateway number GOV-10924)."
# set file name
file_name <- "devel/techreport34.ods"
# Install the pacman package to call all the other packages
if (!require("pacman")) install.packages("pacman")
# Use pacman to install (if req) and load required packages
pacman::p_load(
httr,
readxl,
readODS,
tidyr,
ggplot2,
dplyr,
zoo,
data.table,
scales,
glue,
ggtext,
ggthemes,
pals
)
GET(sheet_path, write_disk(file_name, overwrite = TRUE))
# Import raw data from Excel
covid_variant_data <- read_ods(file_name, sheet = "Fig2", skip = 2)
# set the date format
covid_variant_data$week = as.Date(covid_variant_data$week, "%d/%m/%Y")
# convert wide data to long
covid_variant_data <- gather(covid_variant_data, variant, case_prevelance, "Omicron":last_col())
# create plot and geom
covid_variant_plot <- ggplot() +
# plot data in a stacked format
geom_area(data = covid_variant_data, aes(x = week, y = case_prevelance, group = variant, fill = variant), position = "stack") +
# scale settings
scale_fill_manual(name = "Variant", values = as.vector(tableau20(19))) +
scale_x_date(date_labels = "%b %y", date_breaks = "1 month") +
# axis settings
xlab("Month") +
ylab("Case prevelance percentage") +
# titles
ggtitle("Covid variant prevalence in England") +
labs(caption = paste0(plot_caption," Plotted", Sys.time(), sep = " "), subtitle = paste0(plot_subtitle)) +
# set theme
theme_base() +
theme(
plot.title = element_text(size = 20, family = "Helvetica", face = "bold"),
plot.subtitle = element_markdown(hjust = 0, vjust = 0, size = 11),
plot.caption = element_text(size = 10))
covid_variant_plot
# save to daily file
ggsave("output/england_variants.png", width = 16.6, height = 8.65, units = "in")
# set working directory
setwd("~/Documents/GitHub/dorset_covid")
# Install the pacman package to call all the other packages
if (!require("pacman")) install.packages("pacman")
# Use pacman to install (if req) and load required packages
pacman::p_load(
ggplot2,
tidyr,
dplyr,
zoo,
reshape,
lubridate,
plotly,
data.table,
ggthemes,
ggtext,
ggrepel
)
df_iod <- read.csv(url("https://assets.publishing.service.gov.uk/government/uploads/system/uploads/attachment_data/file/845345/File_7_-_All_IoD2019_Scores__Ranks__Deciles_and_Population_Denominators_3.csv"))
df_lookup <- read.csv(url("http://geoportal1-ons.opendata.arcgis.com/datasets/fe6c55f0924b4734adf1cf7104a0173e_0.csv"))
vaccs_percentage_dor <- read.csv(url("https://api.coronavirus.data.gov.uk/v2/data?areaType=msoa&areaCode=E06000059&metric=cumVaccinationFirstDoseUptakeByVaccinationDatePercentage&metric=cumVaccinationSecondDoseUptakeByVaccinationDatePercentage&metric=cumVaccinationThirdInjectionUptakeByVaccinationDatePercentage&format=csv"))
vaccs_percentage_bcp <- read.csv(url("https://api.coronavirus.data.gov.uk/v2/data?areaType=msoa&areaCode=E06000058&metric=cumVaccinationFirstDoseUptakeByVaccinationDatePercentage&metric=cumVaccinationSecondDoseUptakeByVaccinationDatePercentage&metric=cumVaccinationThirdInjectionUptakeByVaccinationDatePercentage&format=csv"))
# merge vaccination datasets into one
# 1 - place datasets into a single list
vaccs_percentage_list <- list(vaccs_percentage_dor, vaccs_percentage_bcp)
# 2 - merge the datasets in the list into vaccs_combined
vaccs_percentage_combined <- merge_recurse(vaccs_percentage_list)
# keep only the columns we need, and rename the vacc event columns
vaccs_percentage_combined <- subset(vaccs_percentage_combined, select = c("date", "UtlaName", "areaCode", "areaName", "cumVaccinationFirstDoseUptakeByVaccinationDatePercentage", "cumVaccinationSecondDoseUptakeByVaccinationDatePercentage", "cumVaccinationThirdInjectionUptakeByVaccinationDatePercentage"))
names(vaccs_percentage_combined)[names(vaccs_percentage_combined) == "cumVaccinationFirstDoseUptakeByVaccinationDatePercentage"] <- "First"
names(vaccs_percentage_combined)[names(vaccs_percentage_combined) == "cumVaccinationSecondDoseUptakeByVaccinationDatePercentage"] <- "Second"
names(vaccs_percentage_combined)[names(vaccs_percentage_combined) == "cumVaccinationThirdInjectionUptakeByVaccinationDatePercentage"] <- "Third or booster"
# define the date format
vaccs_percentage_combined$date = as.Date(vaccs_percentage_combined$date, "%Y-%m-%d")
# convert wide data into long
vaccs_percentage_long <- gather(vaccs_percentage_combined, event, total, First:last_col())
# work out unvaccinated percentages
vaccs_percentage_long <- vaccs_percentage_long %>%
mutate(unvacc_total = 100 - total)
# create a working dataframe with the Index of Multiple Deprivation columns we need
df_work <- subset(df_iod, select = c("LSOA.code..2011.", "LSOA.name..2011.", "Local.Authority.District.code..2019.", "Local.Authority.District.name..2019.", "Index.of.Multiple.Deprivation..IMD..Score", "Total.population..mid.2015..excluding.prisoners."))
# filter the working dataframe to the Dorset LAs
df_work <- df_work %>%
filter(Local.Authority.District.code..2019. == "E06000059" | Local.Authority.District.code..2019. == "E06000058")
# get the MSOA code from the LSOA/MSOA lookup table
df_work$msoacode <- with(df_lookup, MSOA11CD[match(df_work$LSOA.code..2011., LSOA11CD)])
# get the legacy LA name (pre LGR) from the LSOA/MSOA lookup table - useful for Dorset
df_work$legacylad <- with(df_lookup, LAD17NM[match(df_work$LSOA.code..2011., LSOA11CD)])
# get the geographic MSOA name from the vaccination data
df_work$msoaname <- with(vaccs_percentage_long, areaName[match(df_work$msoacode, areaCode)])
# following the IMD technical guidance, create a IMD multiplier by multiplying LSOA population by IMD score
df_work <- df_work %>%
mutate(msoa_dep_multiplier = Total.population..mid.2015..excluding.prisoners. * Index.of.Multiple.Deprivation..IMD..Score)
# group the LSOAs by MSOA and add their population figures together - creates a new lookup table
df_msoapops <- df_work %>%
group_by(msoacode) %>%
summarise(msoapop = sum(Total.population..mid.2015..excluding.prisoners.))
# group the LSOAs by MSOA and add their multiplied scores together - creates a new lookup table
df_msoaimdscore <- df_work %>%
group_by(msoacode) %>%
summarise(msoaimdagg = sum(msoa_dep_multiplier))
# create the dataset where our IMD score for each MSOA will be calculated, using a subset of df_work
df_msoascores <- subset(df_work, select = c("msoacode", "msoaname", "Local.Authority.District.code..2019.", "Local.Authority.District.name..2019.", "legacylad"))
# remove the duplicate rows to show only unique MSOAs
df_msoascores <- df_msoascores[!duplicated(df_msoascores$msoacode), ]
# get the MSOA's total pupulation from the df_msoapop lookup table
df_msoascores$msoapop <- with(df_msoapops, msoapop[match(df_msoascores$msoacode, msoacode)])
# get the MSOA's total multiplied score from the df_msoaimdscore lookup table
df_msoascores$msoaimdagg <- with(df_msoaimdscore, msoaimdagg[match(df_msoascores$msoacode, msoacode)])
# divide the MSOA's multiplied score by its total populatiom
# this produces an Index of Multiple Deprivation score at MSOA level
df_msoascores <- df_msoascores %>%
mutate(msoa_imd_score = msoaimdagg / msoapop)
# add the MSOA IMD score to the long vaccination data
vaccs_percentage_long$msoa_imd_score <- with(df_msoascores, msoa_imd_score[match(vaccs_percentage_long$areaCode, msoacode)])
# add the legacy LA to the long vaccination data
vaccs_percentage_long$legacylad <- with(df_msoascores, legacylad[match(vaccs_percentage_long$areaCode, msoacode)])
# build plot
unvaxxed_plot <- ggplot(data = subset(vaccs_percentage_long, event == "First")) +
# create scatter plot
geom_point(aes(x = msoa_imd_score, y = unvacc_total, col = legacylad), shape = 15, size = 2) +
# repelling text labels
geom_text_repel(aes(x = msoa_imd_score, y = unvacc_total, label = areaName), size = 1.75, segment.color = "red", max.overlaps = Inf) +
# configure legend and scatter plot colours
scale_colour_manual(name = "Legacy local authority", values = c("Bournemouth" = "royalblue1", "Christchurch" = "grey", "East Dorset" = "orange", "North Dorset" = "darkgreen", "Poole" = "aquamarine3", "Purbeck" = "navy", "West Dorset" = "darkviolet", "Weymouth and Portland" = "green2")) +
# axis labels
xlab("Deprivation score") +
ylab("Unvaccinated percentage") +
# title and subtitle
ggtitle("Comparing covid vaccination status with deprivation") +
labs(caption = paste("Data from UK Health Security Agency and DLUHC / https://coronavirus.data.gov.uk. Plotted", Sys.time(), sep = " "),
subtitle = "Percentage of people aged 12 and over in a MSOA that have not yet received a first covid vaccination, plotted against the MSOA's deprivation score.") +
# theme and theme settings
theme_base() +
theme(
plot.title = element_text(size = 20, family = "Helvetica", face = "bold"),
plot.subtitle = element_markdown(hjust = 0, vjust = 0, size = 11),
plot.caption = element_text(size = 10),
legend.text = element_text(size = 10),
legend.title = element_text(size = 12),
legend.background = element_blank(),
legend.box.background = element_rect(colour = "black"),
axis.title = element_text(size = 12),
axis.text = element_text(size = 10))
# create plot
unvaxxed_plot
# save to daily file
ggsave("output/deprivation_dorset.png", width = 16.6, height = 8.65, units = "in")
# set working directory
setwd("~/Documents/GitHub/dorset_covid")
# Install the pacman package to call all the other packages
if (!require("pacman")) install.packages("pacman")
# Use pacman to install (if req) and load required packages
pacman::p_load(
httr,
readxl,
readODS,
tidyverse,
zoo,
data.table,
scales,
glue,
ggtext,
ggthemes,
pals,
utils,
reshape,
lubridate
)
# set mobility reports zipfile path
zip_path <- "https://www.gstatic.com/covid19/mobility/Region_Mobility_Report_CSVs.zip"
# set downloaded file path and name for downloaded data
file_name <- "devel/Region_Mobility_Report_CSVs.zip"
# download the mobility report zipfile
GET(zip_path, write_disk(file_name, overwrite = TRUE))
# extract the GB data for 2021
unzip(file_name, files = c("2022_GB_Region_Mobility_Report.csv", "2021_GB_Region_Mobility_Report.csv", "2020_GB_Region_Mobility_Report.csv"), overwrite = TRUE, exdir = "./devel/")
# import GB data files
mobility2020 <- read.csv("devel/2020_GB_Region_Mobility_Report.csv")
mobility2021 <- read.csv("devel/2021_GB_Region_Mobility_Report.csv")
mobility2022 <- read.csv("devel/2022_GB_Region_Mobility_Report.csv")
# manually read in lockdown start and end
# data from https://www.instituteforgovernment.org.uk/charts/uk-government-coronavirus-lockdowns
# and https://commonslibrary.parliament.uk/research-briefings/cbp-9068/
# xmin denotes lockdown start, xmax denotes lockdown end
lockdowns <- data.frame(
xmin = c(as.Date(c("2020-03-23")), as.Date(c("2020-11-05")), as.Date(c("2021-01-06"))),
xmax = c(as.Date(c("2020-07-04")), as.Date(c("2020-12-02")), as.Date(c("2021-03-29"))),
ymin = c(-Inf, -Inf, -Inf),
ymax = c(Inf, Inf, Inf)
)
# merge datasets into one
# 1 - place datasets into a single list
mobility_list <- list(mobility2020, mobility2021, mobility2022)
# 2 - merge the datasets in the list into vaccs_combined
mobility_combined <- merge_recurse(mobility_list)
# define the date format
mobility_combined$date = as.Date(mobility_combined$date, "%Y-%m-%d")
# filter only the Dorset data
mobility_combined <- mobility_combined %>%
filter(sub_region_1 == "Dorset" & sub_region_2 == "")
# calculate seven day rolling average
mobility_combined <- mobility_combined %>%
mutate(ret_av = rollmean(retail_and_recreation_percent_change_from_baseline, k = 7, fill = NA)) %>%
mutate(gro_av = rollmean(grocery_and_pharmacy_percent_change_from_baseline, k = 7, fill = NA)) %>%
mutate(par_av = rollmean(parks_percent_change_from_baseline, k = 7, fill = NA)) %>%
mutate(tra_av = rollmean(transit_stations_percent_change_from_baseline, k = 7, fill = NA)) %>%
mutate(wor_av = rollmean(workplaces_percent_change_from_baseline, k = 7, fill = NA)) %>%
mutate(res_av = rollmean(residential_percent_change_from_baseline, k = 7, fill = NA))
# remove the columns we don't need
mobility_combined <- subset(mobility_combined, select = c("date", "sub_region_2", "ret_av", "gro_av", "par_av", "tra_av", "wor_av", "res_av"))
# rename the activity columns
names(mobility_combined)[names(mobility_combined) == "ret_av"] <- "Retail and recreation"
names(mobility_combined)[names(mobility_combined) == "gro_av"] <- "Grocery and pharmacy"
names(mobility_combined)[names(mobility_combined) == "par_av"] <- "Parks"
names(mobility_combined)[names(mobility_combined) == "tra_av"] <- "Public transport hubs"
names(mobility_combined)[names(mobility_combined) == "wor_av"] <- "Workplace"
names(mobility_combined)[names(mobility_combined) == "res_av"] <- "Residential"
# elongate the data
mobility_long <- gather(mobility_combined, activity, percent_change_from_baseline, "Retail and recreation":last_col(), na.rm = FALSE, convert = FALSE)
# create plot and geom
mobility_plot <- ggplot() +
# shaded areas to denote lockdowns
geom_rect(
data = lockdowns,
fill = "lightsteelblue1", alpha = 0.5,
aes(
xmin = xmin,
xmax = xmax,
ymin = ymin,
ymax = ymax
)
) +
# grey line to indicate baseline
geom_hline(yintercept = 0, colour = "black") +
# main data plot
geom_area(data = mobility_long, aes(x = date, y = percent_change_from_baseline), size = 0.75, colour = "springgreen4", fill = "#94d3b2", position = "stack") +
# text annotations to indicate lockdowns
# x value takes the start date from the lockdowns dataframe and adds twelve for positioning
annotate("text", x = lockdowns$xmin[1]+12, y = 250, label = "Lockdown 1", size = 2.5, colour = "darkblue", fontface = "bold", angle = 90) +
annotate("text", x = lockdowns$xmin[2]+12, y = 250, label = "Lockdown 2", size = 2.5, colour = "darkblue", fontface = "bold", angle = 90) +
annotate("text", x = lockdowns$xmin[3]+12, y = 250, label = "Lockdown 3", size = 2.5, colour = "darkblue", fontface = "bold", angle = 90) +
# facet by activity
facet_wrap(~ activity) +
# set scales
scale_x_date(date_labels = "%b %y", date_breaks = "3 months") +
scale_y_continuous(breaks = c(-50, 0, 50, 100, 150, 200, 250, 300)) +
# set axis labels
xlab("Date") +
ylab("Percentage change") +
# set title and subtitle
ggtitle("We're moving around in Dorset differently due to covid-19") +
labs(caption = paste("Data from Google community mobility reports / https://www.google.com/covid19/mobility. Lockdown dates from the Insitute for Government. Plotted", Sys.time(), sep = " ", "\nData plot by Andrew Harrison / https://aharriso11.github.io/dorset_covid"), subtitle = "How visits and lengths of stay at different places change compared to a pre-covid baseline (3rd Jan - 6th Feb 2020), calculated from Google account users who have opted in to location history features.<br>Shaded light blue areas indicate periods of national restrictions.") +
# set theme and customisations
theme_base() +
theme(
axis.text.x = element_text(size = 8),
axis.text.y = element_text(size = 8),
plot.title = element_text(size = 20, family = "Helvetica", face = "bold"),
plot.subtitle = element_markdown(hjust = 0, vjust = 0, size = 11),
plot.caption = element_text(size = 8),
legend.text = element_text(size = 12),
legend.background = element_blank(),
legend.box.background = element_rect(colour = "black"),
axis.title = element_text(size = 12),
axis.text = element_text(size = 8),
strip.text.y = element_text(size = 9.5))
# run the plot
mobility_plot
# save to file
ggsave("output/mobility.png", width = 16.6, height = 8.65, units = "in")
